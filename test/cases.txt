# Booleans

[true, false]

==>

Expression(Array(Boolean, Boolean))

# Numbers

[1, 2.5, 3e-5, 1_500]

==>

Expression(Array(Number, Number, Number, Number))

# Identifiers

[one, Two_Three]

==>

Expression(Array(Identifier, Identifier))

# Null-safe property/method access

one?.two

==>

Expression(ObjectAccess(Identifier, NullSafeMemberOf, Identifier))

# Null-coalescing operator

one ?? "two"

==>

Expression(BinaryExpression(Identifier, Operator, String))

# Ternary expression

condition ? "yes" : "no"

==>

Expression(TernaryExpression(Identifier, String, String))

# Strings

["hello", "one\"\\two", 't"h"ree']

==>

Expression(Array(String, String, String))

# Unary operator

not this

==>

Expression(UnaryExpression(UnaryOperator, Identifier))

# Multi-word operators

"ab" starts with "a"

==>

Expression(BinaryExpression(String, OperatorKeyword, String))

# Binary operators

[1 + 2, true || false, "ab" contains "a"]

==>

Expression(Array(BinaryExpression(Number, Operator, Number), BinaryExpression(Boolean, Operator, Boolean), BinaryExpression(String, OperatorKeyword, String)))

# Arrays

[["a","b","c"], [[2, []]]]

==>

Expression(Array(Array(String, String, String), Array(Array(Number, Array))))

# Objects

[{a: b, "c": 5},{"c": "d"}]

==>

Expression(Array(Object(Identifier, Identifier, String, Number), Object(String, String)))

# Object member access after function call

getObj().prop

==>

Expression(ObjectAccess(FunctionCall(Identifier), MemberOf, Identifier))

# Object method

foo.prop(123)

==>

Expression(FunctionCall(ObjectAccess(Identifier, MemberOf, Identifier), Number))

# Object access within binary expression

is_granted(user, user.self.getGroup()) + user.self

==>

Expression(BinaryExpression(FunctionCall(Identifier, Identifier, FunctionCall(ObjectAccess(ObjectAccess(Identifier, MemberOf, Identifier), MemberOf, Identifier))), Operator, ObjectAccess(Identifier, MemberOf, Identifier)))

# Keywords require breaking character

andnotfound

==>

Expression(Identifier)
